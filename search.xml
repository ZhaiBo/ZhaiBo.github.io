<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[微信小程序实现倒计时的效果]]></title>
    <url>%2F2018%2F06%2F07%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%80%92%E8%AE%A1%E6%97%B6%E7%9A%84%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[实现效果图： 实现思路:&emsp;&emsp;在onload函数里每秒调用一次getOverTime()函数，此函数将毫秒转换成HH:mm:ss的时间格式，最后重新赋值倒计时文本. wxml文件代码: 1&lt;view class=&apos;exam-time&apos;&gt;&#123;&#123;overTime&#125;&#125;&lt;/view&gt; js代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 onLoad: function (options) &#123; let that = this; let endTime = &apos;2018-06-07 19:42:23&apos;; //总剩余秒数 let time = (Date.parse(new Date(endDate)) - Date.parse(new Date())) / 1000; console.log(time); if (time &gt; 0) &#123; setInterval(function () &#123; //每秒调用一次,剩余时间减去1秒 time -= 1; that.getOverTime(time); &#125;, 1000) &#125; else &#123; that.setData(&#123; overTime: &apos;考试结束&apos; &#125;); &#125; &#125;, /** * 将剩余时间转换成毫秒数，换算成 HH:mm:ss的时间格式 */getOverTime: function (overSecond) &#123; let that = this; var overTime; if (null != overSecond &amp;&amp; &quot;&quot; != overSecond) &#123; if (overSecond &gt; 0 &amp;&amp; overSecond &lt; 60 * 60) &#123; // 一小时内 let minute = Math.floor(overSecond / 60 % 60); if (minute &lt; 10) &#123; minute = &apos;0&apos; + minute; &#125; let second = Math.floor(overSecond % 60); if (second &lt; 10) &#123; second = &apos;0&apos; + second; &#125; overTime = minute + &apos;:&apos; + second; &#125; else if (overSecond &gt;= 60 * 60 &amp;&amp; overSecond &lt; 60 * 60 * 24) &#123; //一天内 var hour = Math.floor(overSecond / 3600 % 24); if (hour &lt; 10) &#123; hour = &apos;0&apos; + hour; &#125; let minute = Math.floor(overSecond / 60 % 60); if (minute &lt; 10) &#123; minute = &apos;0&apos; + minute; &#125; let second = Math.floor(overSecond % 60); if (second &lt; 10) &#123; second = &apos;0&apos; + second; &#125; overTime = hour + &apos;:&apos; + minute + &apos;:&apos; + second; &#125; else &#123; return; &#125; &#125; console.log(overTime); that.setData(&#123; overTime: &apos;倒计时&apos; + overTime &#125; ); &#125;]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POI转换Excel为List]]></title>
    <url>%2F2018%2F05%2F17%2FPOI%E8%BD%AC%E6%8D%A2Excel%E4%B8%BAList%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;使用POI将Excel文件转换成List,实现批量导入数据的功能. 引入POI所依赖的Jar包12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.10-FINAL&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.10-FINAL&lt;/version&gt;&lt;/dependency&gt; 转换Excel文件为List集合&emsp;&emsp;这里需要先定义实体，字段数量与Excel列数相同。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/** * @param filePath 文件路径 * @param clazz 自定义实体 */ public static &lt;T&gt; List&lt;T&gt; getListFromExcel(String filePath, Class&lt;T&gt; clazz) throws Exception &#123; if (&quot;&quot;.equals(filePath)) &#123; throw new IllegalArgumentException(&quot;Excel读取错误!&quot;); &#125; InputStream is = new FileInputStream(filePath); //读取Excel内容 List&lt;List&lt;String&gt;&gt; list = ExcelUtil.readExcel(is); List&lt;T&gt; listBean = new ArrayList&lt;T&gt;(); //获取传进来的实体所有setter方法 List&lt;Method&gt; setMethods = getSetMethods(clazz); for (int i = 1; i &lt; list.size(); i++) &#123; T ins = clazz.newInstance(); List&lt;String&gt; listStr = list.get(i); for (int j = 0; j &lt; listStr.size(); j++) &#123; //调用Set方法赋值 if (j &lt; setMethods.size()) &#123; setMethods.get(j).invoke(ins, listStr.get(j)); &#125; &#125; listBean.add(ins); &#125; return listBean; &#125; public static List&lt;List&lt;String&gt;&gt; readExcel(InputStream is) &#123; Workbook wb = null; try &#123; wb = WorkbookFactory.create(is); &#125; catch (Exception e) &#123; throw new IllegalArgumentException(&quot;Excel读取错误!&quot;); &#125; /* 得到第一个sheet */ Sheet sheet = wb.getSheetAt(0); /* 得到Excel的行数 */ int totalRows = sheet.getPhysicalNumberOfRows(); /* 得到Excel的列数 */ int totalCells = 0; if (totalRows &gt;= 1 &amp;&amp; sheet.getRow(0) != null) &#123;// 校验行数 totalCells = sheet.getRow(0).getPhysicalNumberOfCells(); &#125; List&lt;List&lt;String&gt;&gt; dataLst = new LinkedList&lt;List&lt;String&gt;&gt;(); /* 循环Excel的行 */ for (int r = 0; r &lt; totalRows; r++) &#123; Row row = sheet.getRow(r); if (row == null) continue;// 本行为空则结束本次循环 List&lt;String&gt; rowLst = new LinkedList&lt;String&gt;(); /* 循环Excel的列 转换单元格值为String*/ for (int c = 0; c &lt; totalCells; c++) &#123; Cell cell = row.getCell(c); String cellValue = &quot;&quot;; if (null != cell) &#123; switch (cell.getCellType()) &#123; case Cell.CELL_TYPE_NUMERIC: // 数字 cellValue = cell.getNumericCellValue() + &quot;&quot;; break; case Cell.CELL_TYPE_STRING: // 字符串 cellValue = cell.getStringCellValue(); break; case Cell.CELL_TYPE_BOOLEAN: // Boolean cellValue = cell.getBooleanCellValue() + &quot;&quot;; break; case Cell.CELL_TYPE_FORMULA: // 公式 cellValue = cell.getCellFormula() + &quot;&quot;; break; case Cell.CELL_TYPE_BLANK: // 空值 cellValue = &quot;&quot;; break; case Cell.CELL_TYPE_ERROR: cellValue = &quot;非法字符&quot;; break; default: cellValue = &quot;未知类型&quot;; break; &#125; &#125; rowLst.add(cellValue); &#125; /* 保存第r行的第c列 */ dataLst.add(rowLst); &#125; return dataLst; &#125; private static List&lt;Method&gt; getSetMethods(Class clazz) &#123; Class[] parameterTypes = new Class[1]; Field[] fields = clazz.getDeclaredFields(); parameterTypes[0] = null; String filedName = &quot;&quot;; Method method = null; StringBuilder setMethodName = new StringBuilder(); List&lt;Method&gt; setMethods = new ArrayList&lt;Method&gt;(); for (int i = 0; i &lt; fields.length; i++) &#123; fields[i].setAccessible(true); filedName = fields[i].getName(); setMethodName.delete(0,setMethodName.length()); setMethodName.append(&quot;set&quot;).append(filedName.substring(0,1).toUpperCase()).append(filedName.substring(1)); parameterTypes[0] = fields[i].getType(); try &#123; method = clazz.getMethod(setMethodName.toString(), parameterTypes); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; setMethods.add(method); &#125; return setMethods; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
</search>
